---
title: "Building the demographic model"
author: "Claire Powers"
date: "2024-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set-up
```{r start, message=TRUE, warning=TRUE, include=FALSE}
rm(list=ls())

# Packages
library(tidyverse)
library(parallel)
library(doParallel)
library(foreach)
library(EnvStats)

# Plotting
theme_set(theme_bw(base_size=14))
stage.cols = c(seed="springgreen4",juv="blue3",flrg="magenta3")
place.cols = c(Cool ="#175D71" , Warm = "#98463C", Avg = "#D48B47")

# Constants
sizes = c(seed=1,juv=8,flrg=10)

# Functions 
source("ModelFunctions/ParamVals.R")
source("ModelFunctions/logit2prob.R")
source("ModelFunctions/survival_fun.R")
source("ModelFunctions/growth_fun.R")
source("ModelFunctions/subpop_mx_fun.R")
source("ModelFunctions/seednum_fun.R")
```

### Survival function
```{r basic_survival_fun}

# look at survival across a range of regional climate values
surv.clim = data.frame(clim = seq(-20,20,by=0.1),
                       seed=NA,
                       juv=NA,
                       flrg=NA)

for(i in 1:nrow(surv.clim)){
  
    surv_params$clim = surv.clim$clim[i]
    s.rates = do.call(survival_fun,surv_params)
    surv.clim[i,2:4]=s.rates
  
}

plot.df = pivot_longer(surv.clim,cols = !clim, names_to = "stage",values_to = "s.rate")

ggplot(plot.df,aes(x=clim,y=s.rate,color=stage))+
  geom_line(linewidth=1.5)+
  scale_color_manual(values=stage.cols) +scale_y_continuous(limits = c(0,1))+
  labs(title="Survival curves")

rm(i)

```

### Growth function
```{r basic_growth_fun}

# look at survival across a range of regional climate values
grow.clim = data.frame(clim = seq(-15,15,by=0.1),
                       seed=NA,
                       juv=NA)

for(i in 1:nrow(grow.clim)){
  
    growth_params$clim = grow.clim$clim[i]
    g.rates = do.call(growth_fun,growth_params)
    grow.clim[i,2:3]=g.rates
  
}

plot.df = pivot_longer(grow.clim,cols = !clim, names_to = "stage",values_to = "g.rate")
ggplot(plot.df,aes(x=clim,y=g.rate,color=stage))+
  geom_line(linewidth=1.5)+
  scale_color_manual(values=stage.cols,labels=c("juv to flrg","seed to juv")) + 
  scale_y_continuous(limits=c(0,1))+
  ggtitle("Growth curves")

rm(i)
```

### Finding seed # (to set F cell) based on magnitude and direction of aspect effect
```{r seednumbers}

seed_df <- expand.grid(aspect.effect = c(-1,1),
                       asp.mag = 20,
                       # clim = -40:45,
                       seeds=NA,
                       lam=NA)


for(i in 1:nrow(seed_df)){
  
  growth_params.i <- growth_params
  surv_params.i <- surv_params
  
  growth_params.i$asp.effect = surv_params.i$asp.effect = seed_df$aspect.effect[i]
  growth_params.i$asp.mag = surv_params.i$asp.mag = seed_df$asp.mag[i]

  surv.rates <- do.call(survival_fun,surv_params.i)
  
  surv_params.i$clim <- growth_params.i$clim <- seed_df$clim[i]
  
  
  # Get survival/growth matrix (seeds = 0 means no fecundity)
  sg.mx = subpop_mx_fun(surv_params = surv_params.i,growth_params = growth_params.i,seeds.in=0)
  
  # Run seednum_fun through optim function to fund the seed number that gets a lambda value of around 1.01
  seeds.optim = stats::optim(par = 100, fn = basic_seeds_fun, method = "L-BFGS-B", lower=0, upper=10000000, 
                             control = list(factr = 1e-15))
  
  # Save that seed number to the global environment
  seeds.i <- round(seeds.optim$par)
  seed_df$seeds[i] <- seeds.i 
  
  sg.mx[1,3] <- surv.rates["flrg"]*P.flr*seeds.i
  
  seed_df$lam <- Re(eigen(sg.mx)$values[1])

  rm(growth_params.i,surv_params.i,sg.mx,seeds.i,surv.rates)
  
  }

write_csv(seed_df,"ModelFunctions/fecundity.csv")
```

### VERSION 2: Finding seed # (to set F cell) based on magnitude and direction of aspect effect PLUS LONG TERM LAMBDA
# Coarse search
```{r seednumbers}

# Constants
n.subpops=2
asp.effects = c(-1,1)
burn.in = 50
sim.years = 100
years <- burn.in + sim.years
start.cells = F.rows = seq(1,n.subpops*3,by=3)
x.target <- (0.005)^2

# Loop over these
asp.mags =  seq(0,30,1)
clim.sds = seq(0,20,1)
reps <- 20

# Initiate cluster
cl = makeCluster(20)
registerDoParallel(cl = cl)

seed_df_coarse <- 
  foreach(r = 1:reps,.combine=rbind) %:% 
    foreach(asp.mag.i = asp.mags, .combine=rbind, .packages=c("tidyverse","EnvStats")) %:% 
      foreach(clim.sd.i = clim.sds, .combine=rbind, .packages=c("tidyverse","EnvStats")) %dopar% {
        
        # Starting values for while loop
        x <- 1;seeds <- 0;lt.lam <- 0
  
        # Fix clim value to stay the same for the while loop, otherwise you could miss the target
        clims.i <- rnorm(years,sd=clim.sd.i)
        
        lo.seeds <-0 ; hi.seeds <- 10^8 
    
        growth_params.i <- growth_params
        surv_params.i <- surv_params
        growth_params.i$asp.mag <- surv_params.i$asp.mag <- asp.mag.i
  
        while(x>x.target){
          
          seeds <- round((lo.seeds + hi.seeds)/2)
          
          annual.df <- data.frame(yr=1:years, lam=NA)
    
          # Set the starting population vectors
          pop.size = 1000
          pop.vec.t0 = rep(pop.size,3*n.subpops)
          
          for(yr in 1:years){
            
            clim.yr <- clims.i[yr]
            
            growth_params.i$clim <- surv_params.i$clim <- clim.yr
            
            # Initiate a full population MX for current year
            pop.mx <- matrix(data=0,nrow=n.subpops*3,ncol=n.subpops*3)
            
            # Build the full population mx
            for(n in 1:n.subpops){
          
              # Add subpop asp.effect to parameters
              surv_params.i$asp.effect <- growth_params.i$asp.effect <- asp.effects[n]
          
              # Create sub-population matrix
              subpop.mx = subpop_mx_fun(surv_params = surv_params.i,
                                        growth_params = growth_params.i,
                                        seeds.in = seeds)
              
              start.cell = start.cells[n]
              pop.mx[start.cell:(2+start.cell),start.cell:(2+start.cell)]=subpop.mx
              rm(subpop.mx)
              
            } # End subpop loop
            
          # Calc t1 population vector
          pop.vec.t1 = pop.mx%*%pop.vec.t0
            
          lam <- sum(pop.vec.t1)/sum(pop.vec.t0)
          annual.df$lam[yr] <- lam
            
          # Rescale the population vector. 
          pop.vec.t1 = pop.vec.t1/sum(pop.vec.t1)*pop.size
            
          pop.vec.t0 = pop.vec.t1
          rm(pop.vec.t1)
          
          } # End year loop
    
          annual.df <- filter(annual.df, yr>burn.in)
          lt.lam <- geoMean(annual.df$lam)
          x <- (1.005-lt.lam)^2
          
          if((lt.lam - 1.0001)>0){ # If lambda is too high, reset the max.seed value to be the current seed value (lower the ceiling)
            
            hi.seeds <- seeds
            
            } else if((lt.lam - 1.0001)<0){ # If lambda is too low, set the min.seed value to be current seed value (raise the floor)
            
            lo.seeds <- seeds }
    
          # print(c(lt.lam,seeds))
          
      }
  
      # Create output dataframe for this row
      tmp.df = data.frame(asp.mag = asp.mag.i,
                          clim.sd = clim.sd.i,
                          seeds = seeds,
                          rep = r)
      return(tmp.df)

    }

stopCluster(cl)
write_csv(seed_df_coarse,paste0("seeds_coarse_",round(Sys.time(),units="secs"),".csv"))
```


# Fine search
```{r seed_fine_search}

# Results from coarse search
# seed_df_coarse <- read_csv("seeds_coarse_2024-10-31 06:00:24.csv")

# Constants
n.subpops=2
asp.effects = c(-1,1)
burn.in = 50
sim.years = 500
years <- burn.in + sim.years
start.cells = seq(1,n.subpops*3,by=3)

# Loop over these
reps = 20
asp.mags <- seq(0,20,1)
clim.sds <- seq(0,20,1)

# Target: The squared difference between lambda and 1.05 must be smaller than this to end while loop
x.target <- (1 - 1.001)^2


# Initiate cluset
# stopCluster(cl)
cores = detectCores()
cl = makeCluster(20)
registerDoParallel(cl = cl)

seed_df_fine <- 
  foreach(r = 1:reps, .combine=rbind) %:%
   foreach(asp.mag.i = asp.mags, .combine=rbind, .packages=c("tidyverse","EnvStats")) %:% 
    foreach(clim.sd.i = clim.sds, .combine=rbind, .packages=c("tidyverse","EnvStats")) %dopar% {
      
        # Starting values for while loop
        x <- 1;lt.lam <- 0
  
        # Fix clim value to stay the same for the while loop, otherwise you could miss the target
        clims.i <- rnorm(years,sd=clim.sd.i)
        
        seed_df <- filter(seed_df_coarse,asp.mag==asp.mag.i & clim.sd == clim.sd.i)
        
        lo.seeds <- 0; hi.seeds <- 10^8
        
        rm(seed_df)
        
        growth_params.i <- growth_params
        surv_params.i <- surv_params
        growth_params.i$asp.mag <- surv_params.i$asp.mag <- asp.mag.i
  
        while(x>x.target){
          
          seeds <- (lo.seeds + hi.seeds)/2
          
          annual.df <- data.frame(yr=1:years, lam=NA)
    
          # Set the starting population vectors
          pop.size = 1000
          pop.vec.t0 = rep(pop.size,3*n.subpops)
          
          for(yr in 1:years){
            
            clim.yr <- clims.i[yr]
            
            growth_params.i$clim <- surv_params.i$clim <- clim.yr
            
            # Initiate a full population MX for current year
            pop.mx <- matrix(data=0,nrow=n.subpops*3,ncol=n.subpops*3)
            
            # Build the full population mx
            for(n in 1:n.subpops){
          
              # Add subpop asp.effect to parameters
              surv_params.i$asp.effect <- growth_params.i$asp.effect <- asp.effects[n]
          
              # Create sub-population matrix
              subpop.mx = subpop_mx_fun(surv_params = surv_params.i,
                                        growth_params = growth_params.i,
                                        seeds.in = seeds)
              
              start.cell = start.cells[n]
              pop.mx[start.cell:(2+start.cell),start.cell:(2+start.cell)]=subpop.mx
              rm(subpop.mx)
              
            } # End subpop loop
            
          # Calc t1 population vector
          pop.vec.t1 = pop.mx%*%pop.vec.t0
            
          lam <- sum(pop.vec.t1)/sum(pop.vec.t0)
          annual.df$lam[yr] <- lam
            
          # Rescale the population vector. 
          pop.vec.t1 = pop.vec.t1/sum(pop.vec.t1)*pop.size
            
          pop.vec.t0 = pop.vec.t1
          rm(pop.vec.t1)
          
          } # End year loop
    
          annual.df <- filter(annual.df, yr>burn.in)
          lt.lam <- geoMean(annual.df$lam)
          x <- (1.0001-lt.lam)^2
          
          if((lt.lam - 1)>0){ # If lambda is too high, reset the max.seed value to be the current seed value (lower the ceiling)
            
            hi.seeds <- seeds
            
            } else if((lt.lam - 1)<0){ # If lambda is too low, set the min.seed value to be current seed value (raise the floor)
            
            lo.seeds <- seeds }
    
          # print(c(lt.lam,seeds))
          
      }
  
      # Create output dataframe for this row
      tmp.df = data.frame(asp.mag = asp.mag.i,
                          clim.sd = clim.sd.i,
                          seeds = seeds,
                          rep = r)
      return(tmp.df)
}
stopCluster(cl)
write_csv(seed_df_fine,paste0("seeds_fine_",round(Sys.time(),units="secs"),".csv"))


```


```{r maxLam_by_climSD}

asp.effects <- c(-1,1)
n.subpops <- length(asp.effects)
burn.in <- 50
sim.years <- 500
years <- burn.in + sim.years
start.cells <- F.rows <- seq(1,n.subpops*3,by=3)
seeds <- 200

# Loop over these
reps <- 20
asp.mags <- seq(0,30,1)
clim.sds <- seq(0,30,1)

# Initiate cluster
# stopCluster(cl)
cores = detectCores()
cl = makeCluster(20)
registerDoParallel(cl = cl)

maxLam_by_climsd_df <- 
  foreach(r = 1:reps, .combine=rbind) %:%
   foreach(asp.mag.i = asp.mags, .combine=rbind, .packages=c("tidyverse","EnvStats")) %:% 
    foreach(clim.sd.i = clim.sds, .combine=rbind, .packages=c("tidyverse","EnvStats")) %dopar% {
      
      annual.df <- data.frame(yr=1:years, lam=NA)
      # 
      # asp.mag.i <- 20  
      # clim.sd.i <- 20
        
      growth_params.i <- growth_params
      surv_params.i <- surv_params
      growth_params.i$asp.mag <- surv_params.i$asp.mag <- asp.mag.i
          
      # Set the starting population vectors
      pop.size = 1000
      pop.vec.t0 = rep(pop.size,3*n.subpops)
      
      for(yr in 1:years){
        
        clim.yr <- rnorm(1,sd=clim.sd.i)
        
        growth_params.i$clim <- surv_params.i$clim <- clim.yr
        
        # Initiate a full population MX for current year
        pop.mx <- matrix(data=0,nrow=n.subpops*3,ncol=n.subpops*3)
        
        # Build the full population mx
        for(n in 1:n.subpops){
      
          # Add subpop asp.effect to parameters
          surv_params.i$asp.effect <- growth_params.i$asp.effect <- asp.effects[n]
      
          # Create sub-population matrix
          subpop.mx = subpop_mx_fun(surv_params = surv_params.i,
                                    growth_params = growth_params.i,
                                    seeds.in = seeds)
          
          start.cell = start.cells[n]
          pop.mx[start.cell:(2+start.cell),start.cell:(2+start.cell)]=subpop.mx
          rm(subpop.mx)
          
          } # End subpop loop
        
        # Calc t1 population vector
        pop.vec.t1 = pop.mx%*%pop.vec.t0
        
        lam <- sum(pop.vec.t1)/sum(pop.vec.t0)
        annual.df$lam[yr] <- lam
        
        # Rescale the population vector. 
        pop.vec.t1 = pop.vec.t1/sum(pop.vec.t1)*pop.size
        
      pop.vec.t0 = pop.vec.t1
      rm(pop.vec.t1)
      
      } # End year loop
      
      annual.df <- filter(annual.df,yr>burn.in)
      lt.lam <- geoMean(annual.df$lam)

      out_df <- data.frame(clim.sd = clim.sd.i,
                           asp.mag = asp.mag.i,
                           lt.lam = lt.lam,
                           rep = r)

      return(out_df)
      
  } # End parallel/outer loops
stopCluster(cl)
write_csv(maxLam_by_climsd_df,paste0("maxLam_",round(Sys.time()),".csv"))

ggplot(maxLam_by_climsd_df,aes(x=clim.sd,y=lt.lam,color=factor(asp.mag)))+
  geom_smooth()

ggplot(filter(maxLam_by_climsd_df,asp.mag==20),aes(x=clim.sd,y=lt.lam,color=factor(asp.mag)))+
  geom_smooth()

seed_climsd_df <- maxLam_by_climsd_df %>% 
  group_by(asp.mag,clim.sd) %>% # For each clim.sd/asp.mag combination
  summarise(mean.lt.lam = mean(lt.lam)) %>% # Find the mean lt lambda value
  group_by(asp.mag) %>% # Then for each asp.mag
  slice_max(order_by = mean.lt.lam,n = 1) %>% # find the clim.sd where the mean.lt.lam value is highest
  mutate(seeds = NA) # %>% expand_grid(reps = 1:10,.)

```


```{r seeds_search}
asp.effects <- c(-1,1)
n.subpops <- length(asp.effects)
burn.in <- 50
sim.years <- 500
years <- burn.in + sim.years
start.cells <- F.rows <- seq(1,n.subpops*3,by=3)

seed_climsd_df <- maxLam_by_climsd_df %>% 
  group_by(asp.mag,clim.sd) %>% # For each clim.sd/asp.mag combination
  summarise(mean.lt.lam = mean(lt.lam),
         max.lt.lam = max(lt.lam)) %>% # Find the mean lt lambda value
  group_by(asp.mag) %>% # Then for each asp.mag
  slice_max(order_by = mean.lt.lam,n = 1) %>% # find the clim.sd where the mean.lt.lam value is highest
  mutate(seeds = NA)

x.target <- (0.001)^2
reps <- 20

# Initiate cluster
# stopCluster(cl)
cl = makeCluster(reps)
registerDoParallel(cl = cl)

seed_search <- foreach(r = 1:reps, .combine=rbind, .packages=c("tidyverse","EnvStats")) %dopar% {
  for(i in 1:nrow(seed_climsd_df)){
    
    timeStart <- round(Sys.time(),units='mins')
        
    growth_params.i <- growth_params
    surv_params.i <- surv_params
    growth_params.i$asp.mag <- surv_params.i$asp.mag <- seed_climsd_df$asp.mag[i]
    
    lt.lam <- 0.9
    lo.seeds <- 0;hi.seeds <- 10^8
    
    clims <- rnorm(n = years,mean = 0,sd = seed_climsd_df$clim.sd[i])
    x <- 1
    
    while(x>x.target){
      
      annual.df <- data.frame(yr=1:years,
                            clim=clims,
                            lam=NA)
      
      seeds <- (lo.seeds + hi.seeds)/2
          
      # Set the starting population vectors
      pop.size = 1000
      pop.vec.t0 = rep(pop.size,3*n.subpops)
      
      for(yr in 1:years){
        
          clim.yr <- annual.df$clim[yr]
          
          growth_params.i$clim <- surv_params.i$clim <- clim.yr
          
          # Initiate a full population MX for current year
          pop.mx <- matrix(data=0,nrow=n.subpops*3,ncol=n.subpops*3)
          
        # Build the full population mx
        for(n in 1:n.subpops){
      
          # Add subpop asp.effect to parameters
          surv_params.i$asp.effect <- growth_params.i$asp.effect <- asp.effects[n]
      
          # Create sub-population matrix
          subpop.mx = subpop_mx_fun(surv_params = surv_params.i,
                                    growth_params = growth_params.i,
                                    seeds.in = seeds)
          
          start.cell = start.cells[n]
          pop.mx[start.cell:(2+start.cell),start.cell:(2+start.cell)]=subpop.mx
          rm(subpop.mx)
          
          } # End subpop loop
        
        # Calc t1 population vector
        pop.vec.t1 = pop.mx%*%pop.vec.t0
        
        lam <- sum(pop.vec.t1)/sum(pop.vec.t0)
        annual.df$lam[yr] <- lam
        
        # Rescale the population vector. 
        pop.vec.t1 = pop.vec.t1/sum(pop.vec.t1)*pop.size
        
        pop.vec.t0 = pop.vec.t1
        rm(pop.vec.t1)
      
      } # End year loop
      
      annual.df <- filter(annual.df,yr>burn.in)
      lt.lam <- geoMean(annual.df$lam)
      # print(c(lt.lam,seeds))
      
      x <- (lt.lam - 1)^2
      
      if((lt.lam - 1)>0){ # If lambda is too high, set the max.seed value to be the current seed value (lower the ceiling)
  
          hi.seeds <- seeds
  
          } else if((lt.lam - 1)<0){ # If lambda is too low, set the min.seed value to be current seed value (raise the floor)
  
          lo.seeds <- seeds }
      
      # print(c(lt.lam,seeds))
      
    }
  
    seed_climsd_df$seeds[i] <- seeds
    seed_climsd_df$rep <- r
    
    # print(c(i,difftime(time1 = Sys.time(), time2=timeStart)))
    
  }
  return(seed_climsd_df)
}
stopCluster(cl)

write_csv(seed_search,paste0("seedSearch_",Sys.time(),".csv"))

ggplot(filter(seed_search,asp.mag==25),aes(x=seeds))+
  geom_histogram()
```


# Plot fine search results
```{r}

seeds1 <- read_csv("seeds_fine_2024-11-04 08:33:55.csv")
seeds2 <- read_csv("seeds_fine_2024-11-04 10:46:14.csv") %>% 
  mutate(rep = rep+20)

seeds <- rbind(seeds1,seeds2)

ggplot(filter(seeds,asp.mag==15,clim.sd==30),aes(x=seeds))+
  geom_histogram(bins=40)


```


```{r more_growthFun}

growth_df = expand.grid(asp.effect = c(-1,1),
                        asp.mag = 20,
                        clim = rnorm(n=1000,sd=15),
                        seed = NA, juv = NA)

for(i in 1:nrow(growth_df)){

  growth_df[i,c('seed','juv')] = growth_fun(sizes = growth_params$sizes,
                 max.growth.rates = growth_params$max.growth.rates,
                 min.growth.rates = growth_params$min.growth.rates,
                 G_2 = growth_params$G_2,
                 G_3 = growth_params$G_3,
                 asp.mag = growth_df$asp.mag[i],
                 asp.effect = growth_df$asp.effect[i],
                 clim = growth_df$clim[i])

}

ggplot(growth_df,aes(x=clim,y=seed,color=as.factor(asp.effect)))+
  geom_line()+
  geom_vline(xintercept=0)+
  facet_wrap(~asp.mag)+
  theme_bw()+
  scale_y_continuous(limits = c(0,1))

ggplot(growth_df,aes(x=clim,y=juv,color=as.factor(asp.effect)))+
  geom_line()+
  geom_vline(xintercept=0)+
  facet_wrap(~asp.mag)+
  theme_bw()+
  scale_y_continuous(limits = c(0,1))

```


#### Look at survival fun across range of clim var, asp.eff, asp.mag ####
```{r more_survivalFun}

surv_df = expand.grid(asp.effect = c(-1,1),
                      asp.mag = 20,
                      clim = rnorm(n=1000,sd=15),
                      seed = NA, juv = NA,flrg=NA)

for(i in 1:nrow(surv_df)){

  surv_df[i,c('seed','juv',"flrg")] =
    survival_fun(sizes = surv_params$sizes,
                 max.survival.rates = surv_params$max.survival.rates,
                 min.survival.rates = surv_params$min.survival.rates,
                 S_2 = surv_params$S_2,
                 S_3 = surv_params$S_3,
                 asp.mag = surv_df$asp.mag[i],
                 asp.effect = surv_df$asp.effect[i],
                 clim = surv_df$clim[i])

}

surv_df = surv_df %>%
  mutate(place.name = case_when(asp.effect==-1~"Cool",
                                asp.effect==0~"Avg",
                                asp.effect==1~"Warm"))

ggplot(surv_df,aes(x=clim,y=seed,color=place.name))+
  geom_line()+
  geom_vline(xintercept=0)+
  facet_wrap(~asp.mag)+
  theme_bw()+
  scale_color_manual(values=place.cols)

ggplot(surv_df,aes(x=clim,y=juv,color=as.factor(asp.effect)))+
  geom_line()+
  geom_vline(xintercept=0)+
  facet_wrap(~asp.mag)+
  theme_bw()

ggplot(surv_df,aes(x=clim,y=flrg,color=as.factor(asp.effect)))+
  geom_line()+
  geom_vline(xintercept=0)+
  facet_wrap(~asp.mag)+
  theme_bw()

```


